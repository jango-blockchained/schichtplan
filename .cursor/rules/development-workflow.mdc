---
description: Development Environment Setup
globs: 
alwaysApply: false
---
# Schichtplan Development Workflow

## Development Environment Setup

### Backend Environment (Bun/ElysiaJS)

```bash
# Navigate to the backend directory
cd src/bun-backend

# Install dependencies (includes bun-types, elysia, etc.)
bun install

# Initialize database schema (run once or when schema changes)
bun run db:init

# Set up environment variables (optional, e.g., for port)
# export PORT=5001
```

### Frontend Environment

```bash
# Navigate to the frontend directory
cd src/frontend

# Install dependencies
bun install  # or: npm install
```

## Common Development Tasks

### Feature Development Workflow

1.  **Create a new branch**: (Same as before)
    ```bash
    git checkout -b feature/feature-name
    ```

2.  **Implement backend changes** (`src/bun-backend/`):
    *   Define/modify schema interfaces in `db/schema.ts`.
    *   Update `db/init-schema.sql` and potentially `db/migrate.ts` if schema changes.
    *   Create/modify service functions in `services/*.ts` (using `bun:sqlite`).
    *   Create/modify routes/handlers in `routes/*.ts` (using ElysiaJS).
    *   Add unit tests in `services/*.test.ts`.
    *   Add integration/API tests in `routes/*.test.ts`.

3.  **Implement frontend changes** (`src/frontend/`):
    *   Add/modify components in `src/components/`.
    *   Update API service calls in `src/services/api.ts` or feature-specific hooks.
    *   Update types in `src/types/`.

4.  **Test changes**:
    *   Run backend tests: `cd src/bun-backend && bun test`
    *   Run frontend tests: `cd src/frontend && bun test` (or specific command)
    *   Manual testing with the app running (see `run-server.mdc`).

5.  **Commit changes**: (Same as before)
    ```bash
    git add .
    git commit -m "Add feature xyz"
    git push origin feature/feature-name
    ```

## Code Style and Best Practices

### Backend Code Style (TypeScript/Bun)

*   Follow standard TypeScript best practices.
*   Use clear type definitions (interfaces, enums).
*   Keep services focused on business logic, routes on request/response handling.
*   Format code with Prettier/Biome:
    ```bash
    # Assuming Prettier setup
    cd src/bun-backend && bun run format
    # Or using Biome: bunx @biomejs/biome format --write .
    ```
*   Run ESLint/Biome for linting:
    ```bash
    # Assuming ESLint setup
    cd src/bun-backend && bun run lint
    # Or using Biome: bunx @biomejs/biome lint --apply .
    ```
*   Consider dependency injection for testability (especially for DB connection).

### Frontend Code Style (TypeScript/React)

*   (Same as before - Follow the TypeScript style guide, use functional components, etc.)
*   Format code with Prettier:
    ```bash
    cd src/frontend && bun run format
    ```
*   Run ESLint:
    ```bash
    cd src/frontend && bun run lint
    ```

## Adding New Features

### Adding a New API Endpoint

1.  Define necessary schema interfaces in `src/bun-backend/db/schema.ts`.
2.  Update `src/bun-backend/db/init-schema.sql` if schema changes.
3.  Create service functions in `src/bun-backend/services/*.ts` with DB logic (`bun:sqlite`).
4.  Add routes/handlers in `src/bun-backend/routes/*.ts` using ElysiaJS.
5.  Mount the new route module in `src/bun-backend/index.ts`.
6.  Run `bun run db:init` if schema changed.
7.  Add tests in `src/bun-backend/services/` and `src/bun-backend/routes/`.

### Adding a New Frontend Component

*   (Same as before - Create component, define types, add API calls, update parent, add tests).

## Debugging

### Backend Debugging (Bun/ElysiaJS)

*   Check console output from `bun run dev`.
*   Use `console.log` statements strategically.
*   Utilize Bun's debugger (refer to Bun documentation).
*   Inspect the SQLite database directly (`src/bun-backend/data/schichtplan.db`) using tools like DB Browser for SQLite.

### Frontend Debugging

*   (Same as before - Use browser dev tools, React Dev Tools, console.log, debugger statement).

## Performance Optimization

### Backend Optimization (Bun/SQLite)

*   Use appropriate SQLite indexes (see `init-schema.sql`).
*   Optimize SQL queries (use `EXPLAIN QUERY PLAN`).
*   Consider prepared statements for frequently run queries (handled by `db.query()`).
*   Cache expensive operations if applicable.
*   Profile code if needed.

### Frontend Optimization

*   (Same as before - Minimize re-renders, use React.memo, optimize assets, code splitting).

## Deployment Considerations

*   Use environment variables for configuration (e.g., `PORT`, `DATABASE_PATH`).
*   Run backend using `bun run start`.
*   Build frontend assets (`cd src/frontend && bun run build`).
*   Ensure `bun run db:init` is run on the deployment target.
*   Configure CORS appropriately for the production domain.
*   Set up proper logging (consider more robust logging than `console.log`). 