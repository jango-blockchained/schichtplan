---
description: Instructions
globs: 
---
## Project: Shift Scheduling Automation Application - "ShiftWise" (Example Name)

**Overall Goal:** Develop a web application that automatically generates 4-week shift schedules for a retail store, adhering to complex constraints, allowing for manual adjustments, and producing printable PDF reports.

## Level 1: Overall Application Architecture and Goals

**Objective:** Create a shift scheduling application ("ShiftWise") that automatically generates weekly schedules for a retail store, adhering to specific constraints and rules.

**Application Name:** ShiftWise

**Platform:** Web Application

**Core Features:**

1.  **Employee Management:**
    *   Input and store employee data: Name, Employee Group (VL, TZ, GfB, TL), Contracted Hours, Availability (optional, for future expansion).
    *   Ability to edit and update employee information.

2.  **Shift Definition:**
    *   Predefined shift types: Frühschicht (Early), Mittelschicht (Middle), Spätschicht (Late).
    *   Configurable shift start/end times (default to store opening hours: 09:00-20:00).
    *   Ability to adjust these times if needed.

3.  **Schedule Generation:**
    *   Automatic generation of a 4-week schedule (Monday-Saturday, for the upcoming month or a user-selected period).
    *   6 entries per page in the PDF output (visual layout detail to be defined in Level 3).
    *   Each row represents an employee's shift for a specific day.
    *   Adherence to all constraints (employee group rules, working hour limits, break times, min/max employees per shift, keyholder rules, delivery day rules).

4.  **User Interface:**
    *   Clear and intuitive display of the generated schedule (tabbed interface for weeks).
    *   Easy navigation and interaction.
    *   "Edit Schedule" mode for manual adjustments (with constraint validation).
    *   Confirmation dialog before saving/printing.
    *   "Save" and "Save & Print" buttons.
    *   Ability to export the schedule as a landscape DIN A4 PDF.

5.  **Constraint Validation:**
    *   Real-time validation of all rules during automatic generation and manual adjustments.
    *   Clear error/warning messages to the user when constraints are violated.

6.  **Data Persistence:**
    *   Store employee data, generated schedules, and store configuration in a PostgreSQL database.

7.  **Schedule Period Management:**
    *   Ability to select the 4-week period for schedule generation (defaulting to the next month).

8.  **Store Configuration:**
    *   A section (likely in settings) to manage store details: opening hours, shift definitions (start/end times).

## Level 2: Detailed Functional Requirements and Logic

**2.1 Employee Management:**

*   **Data Fields:**
    *   Employee ID (unique 3 letter identifier based on First and Last Name)
    *   First Name
    *   Last Name
    *   Employee Group (VL, TZ, GfB, TL) - Use a dropdown/select in the UI.
    *   Contracted Weekly Hours (number, with validation based on Employee Group)
    *   Availability (optional, for future use - days of the week, time ranges)
*   **Validation Rules:**
    *   VL: 40 hours/week
    *   TZ: 10, 20, or 30 hours/week
    *   GfB: Max 40 hours/month
    *   TL: 40 hours/week
    *   Daily working hours:
        *   GfB & TZ: 3-8 hours
        *   VZ & TL: 4-10 hours

**2.2 Shift Definition:**

*   **Shift Types:**
    *   Frühschicht (Early): Default 09:00 - (variable end time)
    *   Mittelschicht (Middle): (variable start/end times)
    *   Spätschicht (Late): (variable start time) - 20:00 (or 20:10 for keyholder)
*   **Keyholder:**
    *   Flag an employee as a keyholder (boolean).
    *   Keyholder Spätschicht end: 20:10
    *   Keyholder Frühschicht start: 08:55
    *   Keyholder must work Frühschicht the day after Spätschicht.

**2.3 Schedule Generation Algorithm:**

1.  **Initialization:**
    *   Create an empty 4-week schedule (24 days x N employees, considering 4 weeks of 6 days each).
    *   Retrieve all employee data.
    *   Retrieve shift definitions.
    *   Determine the 4-week period (start and end dates) based on user input (or default to the next month).

2.  **Constraint Preprocessing:**
    *   Identify Tuesday and Thursday as high-staffing days.
    *   Identify keyholder(s).

3.  **Shift Assignment (Core Logic - Iterative Process):**
    *   **Prioritize:**
        *   Keyholder Spätschicht/Frühschicht assignments.
        *   Tuesday and Thursday staffing (maximize employees per shift).
        *   TL and VL employees (to ensure their 40 hours are filled).
    *   **For each day:**
        *   **For each shift (Früh, Mittel, Spät):**
            *   Determine the number of employees needed (based on min/max rules and day).
            *   Select eligible employees:
                *   Check employee group constraints (working hour limits).
                *   Check weekly/monthly hour limits (especially for GfB).
                *   Check for keyholder constraints.
                *   Check if the employee has already worked a shift that day.
                *   Consider break time rules (>6 hours work = 60 min break).
            *   Assign employees to the shift, updating their worked hours.
            *   If not enough employees are available, flag the issue.
    *   **Iterate:** Repeat until a valid schedule is generated or a maximum number of attempts is reached.

4.  **Break Calculation:**
    *   Calculate break times based on total shift length.
    *   Insert break periods into the schedule.

5.  **Validation:**
    *   Re-validate the entire schedule against all constraints.
6. **Output:**
    *  Return schedule data for display and editing.

**2.4 User Interface (UI):**

*   **Schedule Display:**
    *   Tabbed interface: One tab per week.
    *   Table layout within each tab: Days (columns), Employees (rows).
    *   Cells:
        *   Shift type (F, M, S).
        *   Start and end times.
        *   Break time.
        *   Color-coding.
    *   Total worked hours per employee per week.
    *   Clearly indicate the 4-week period.
*   **Employee Management UI:**
    *   Form for adding/editing employee data.
    *   Table to list all employees.
*   **Store Configuration UI:**
    *  Form to edit store hours and shift definitions.
*   **Controls:**
    *   "Generate Schedule" button.
    *   "Edit Schedule" button (toggles edit mode).
    *   "Save" button (saves changes, prompts for confirmation).
    *   "Save & Print" button (saves, prompts, then generates PDF).
*   **Edit Mode:**
    *   Drag-and-drop shifts.
    *   Direct editing of shift times (with validation).
    *   Visual indication of changes.
*   **Confirmation Dialog:**
    *   Modal dialog before saving/printing: "Are you sure you want to save these changes?"

**2.5 Data Persistence:**

*   **Database Schema:**
    *   **Employees Table:** EmployeeID (PK), FirstName, LastName, EmployeeGroup, ContractedHours, Keyholder (boolean), ...
    *   **Shifts Table:** ShiftID (PK), ShiftType, StartTime, EndTime
    *   **Schedule Table:** ScheduleID (PK), EmployeeID (FK), ShiftID (FK), Date, BreakStart, BreakEnd
    *   **StoreConfig Table:** ConfigID (PK), OpeningTime, ClosingTime, ... (shift definitions)

**2.6 PDF Generation:**

*   Use a library (e.g., `jsPDF` client-side, or `PDFKit`/`Puppeteer` server-side).
*   **Layout:**
    *   Landscape orientation.
    *   DIN A4 size.
    *   Multiple pages (6 entries per page).
    *   Headers: Store name, date range, employee names, day of the week.
    *   Shift times, breaks, employee names.
    *   Legend for shift abbreviations.

## Level 3: UI/UX Design and Implementation Details

**3.1 Wireframes/Mockups:**

*   Create wireframes for:
    *   Tabbed 4-week schedule view.
    *   Edit mode interactions.
    *   Confirmation dialog.
    *   Employee management form.
    *   Employee list.
    *   Store configuration settings page.

**3.2 Visual Design:**

*   Choose color scheme, typography, and visual style.
*   Design table layout: cell size, spacing, fonts, color-coding.
*   Design form elements.

**3.3 Front-End Implementation (React):**

*   Implement UI components.
*   Data binding with back-end API.
*   Real-time validation feedback.
*   Tabbed interface.
*   Drag-and-drop (e.g., `react-beautiful-dnd`).
*   Confirmation dialog (modal component).
*   Client-side PDF generation (`jsPDF`) or trigger server-side generation.

**3.4 Back-End Implementation (Node.js with Express):**

*   API endpoints:
    *   CRUD for employees.
    *   CRUD for shifts (if customizable).
    *   Schedule generation.
    *   Schedule retrieval.
    *   Schedule saving.
    *   Retrieving/updating store configuration.
    *   (Optional) Server-side PDF generation.
*   Implement schedule generation algorithm.
*   Connect to PostgreSQL database.

## Level 4: Testing and Refinement

**4.1 Unit Testing:**

*   Test individual functions/components (shift assignment, validation, API endpoints).

**4.2 Integration Testing:**

*   Test interaction between components (front-end to back-end, back-end to database).
*   Test manual editing, save/print workflow, confirmation dialog.
*   Test PDF generation.

**4.3 User Acceptance Testing (UAT):**

*   Real users test with realistic data.
*   Focus on usability of manual editing.
*   Ensure PDF output is correct.

**4.4 Algorithm Refinement:**

*   Refine algorithm based on testing and feedback.

**4.5 Performance Optimization:**

*   Optimize database queries and API calls.
*   Optimize front-end rendering.

## Level 5: Deployment and Maintenance

**5.1 Deployment:**

*   Choose hosting provider (AWS, Google Cloud, Heroku, Netlify).
*   Deploy front-end and back-end.
*   Configure database.
*   Set up environment variables.

**5.2 Maintenance:**

*   Monitor performance and errors.
*   Update dependencies.
*   Address bug reports and feedback.
*   Plan for future enhancements.


# Layout template

create a table based layout based on the @shift_table.jpg without the handdrawn entries
